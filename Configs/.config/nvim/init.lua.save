-- init.lua
-- repository: https://github.com/zhaleff/hyprcraft
-- author:
-- LICENCE: MIT


-- === LÍDERES ===
vim.g.mapleader = " "
vim.g.maplocalleader = " "

-- === OPCIONES GENERALES ===
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.tabstop = 2
vim.opt.shiftwidth = 2
vim.opt.expandtab = true
vim.opt.smartindent = true
vim.opt.wrap = false
vim.opt.cursorline = true
vim.opt.termguicolors = true
vim.opt.mouse = "a"
vim.opt.clipboard = "unnamedplus"
vim.opt.ignorecase = true
vim.opt.smartcase = true
vim.opt.updatetime = 250
vim.opt.timeoutlen = 400
vim.opt.undofile = true
vim.opt.swapfile = false
vim.opt.signcolumn = "yes"
vim.opt.scrolloff = 0
vim.opt.sidescrolloff = 8
vim.opt.showmode = false
vim.opt.breakindent = true
vim.opt.linebreak = true
vim.opt.list = true
vim.opt.listchars = { tab = "» ", trail = "·", nbsp = "␣" }
vim.opt.pumblend = 10
vim.opt.winblend = 10
vim.opt.splitkeep = "screen"
vim.opt.splitbelow = true
vim.opt.splitright = true
vim.opt.hlsearch = false

-- === LAZY.NVIM BOOTSTRAP ===
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git", "clone", "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git", "--branch=stable", lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

-- === PLUGINS ===
require("lazy").setup({
  {
    "catppuccin/nvim",
    name = "catppuccin",
    priority = 1000,
    config = function()
      local ctp_feline = require('catppuccin.special.feline')
      ctp_feline.setup()
      require("feline").setup({
        components = ctp_feline.get_statusline(),
      })

      ctp_feline.setup({
        view = {
          lsp = {
            name = true
          }
        }
      })
      require("catppuccin").setup({
        flavour = "mocha",
        transparent_background = false,
        show_end_of_buffer = false,
        term_colors = true,
        dim_inactive = { enabled = true, percentage = 0.15 },
        styles = {
          comments = { "italic" },
          functions = { "bold" },
          keywords = { "italic" },
          variables = { "italic" },
        },
        integrations = {
          cmp = true,
          gitsigns = true,
          nvimtree = true,
          telescope = { enabled = true },
          treesitter = true,
          dashboard = true,
          which_key = true,
          indent_blankline = { enabled = true, scope_color = "mauve" },
          mini = { enabled = true },
          native_lsp = {
            enabled = true,
            virtual_text = {
              errors = { "italic" },
              hints = { "italic" },
              warnings = { "italic" },
              information = { "italic" },
            },
            underlines = {
              errors = { "underline" },
              hints = { "undercurl" },
              warnings = { "underline" },
              information = { "underline" },
            },
          },
        },
      })
      vim.cmd.colorscheme("catppuccin")
    end,
  },

  { "neovim/nvim-lspconfig" },

  {
    "williamboman/mason.nvim",
    build = ":MasonUpdate",
    config = true,
  },

  {
    "williamboman/mason-lspconfig.nvim",
    config = function()
      require("mason").setup()
      require("mason-lspconfig").setup({
        ensure_installed = {
          "lua_ls",
          "pyright",
          "html",
          "cssls",
          "bashls",
          "jsonls",
          "emmet_language_server",
        },
        automatic_installation = true,
      })
    end,
  },

  {
    "nvim-telescope/telescope.nvim",
    branch = "0.1.x",
    dependencies = {
      "nvim-lua/plenary.nvim",
      { "nvim-telescope/telescope-fzf-native.nvim", build = "make" },
    },
    config = function()
      local telescope = require("telescope")
      telescope.setup({
        defaults = {
          prompt_prefix = "  ",
          selection_caret = "  ",
          layout_strategy = "horizontal",
          layout_config = { prompt_position = "top", height = 0.9, width = 0.9 },
          sorting_strategy = "ascending",
          mappings = {
            i = {
              ["<C-j>"] = "move_selection_next",
              ["<C-k>"] = "move_selection_previous",
            },
          },
        },
        pickers = {
          find_files = { hidden = true },
          live_grep = { additional_args = { "--hidden", "--glob=!.git/" } },
        },
      })
      telescope.load_extension("fzf")
    end,
  },

  {
    'feline-nvim/feline.nvim',
    lazy = true,
  },

  {
    "nvim-tree/nvim-tree.lua",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    config = function()
      require("nvim-tree").setup({
        view = { width = 35, side = "left", adaptive_size = true },
        renderer = {
          group_empty = true,
          highlight_git = true,
          icons = { show = { file = true, folder = true, folder_arrow = true, git = true } },
        },
        filters = { dotfiles = true, custom = { "^.git$" } },
        git = { enable = true, ignore = false },
        update_focused_file = { enable = true, update_root = false },
      })
    end,
  },

  {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    config = function()
      require("nvim-treesitter.configs").setup({
        ensure_installed = {
          "html", "css", "javascript", "typescript",
          "lua", "python", "bash", "vue", "svelte",
        },
        highlight = { enable = true },
        indent = { enable = true },
        auto_install = true,
      })
    end,
  }, 
  {
    "windwp/nvim-autopairs",
    event = "InsertEnter",
    opts = {
      check_ts = true,
      ts_config = {
        lua = { "string" },
        javascript = { "template_string" },
        typescript = { "template_string" },
        vue = { "template_string" },
      },
      fast_wrap = {
        map = "<M-e>",
        chars = { "{", "[", "(", '"', "'" },
        pattern = [=[[%'%"%)%>%]%)%}%,]]=],
        end_key = "$",
        keys = "qwertyuiopzxcvbnmasdfghjkl",
        check_comma = true,
        highlight = "Search",
        highlight_grey = "Comment",
      },
    },
  },

  {
    "windwp/nvim-ts-autotag",
    config = function()
      require("nvim-ts-autotag").setup({
        filetypes = {
          "html", "javascript", "typescript", "javascriptreact",
          "typescriptreact", "svelte", "vue", "tsx", "jsx",
        },
      })
    end,
  },

  {
    "akinsho/bufferline.nvim",
    version = "*",
    dependencies = "nvim-tree/nvim-web-devicons",
    config = function()
      require("bufferline").setup({
        options = {
          diagnostics = "nvim_lsp",
          offsets = { { filetype = "NvimTree", text = "Explorer", padding = 1 } },
          separator_style = "thin",
          indicator = { style = "underline" },
          hover = { enabled = true, delay = 200, reveal = { "close" } },
        },
      })
    end,
  },

  { "numToStr/Comment.nvim", config = true },

  {
    "L3MON4D3/LuaSnip",
    version = "v2.*",
    build = "make install_jsregexp",
    dependencies = {
      "rafamadriz/friendly-snippets",
      "honza/vim-snippets",
    },
    config = function()
      require("luasnip.loaders.from_vscode").lazy_load({
        paths = {
          vim.fn.stdpath("config") .. "/snippets",
          vim.fn.stdpath("data") .. "/lazy/friendly-snippets",
          vim.fn.stdpath("data") .. "/lazy/vim-snippets",
        }
      })
      require("luasnip.loaders.from_lua").load({ paths = vim.fn.stdpath("config") .. "/lua/snippets" })

      vim.keymap.set({ "i", "s" }, "<C-l>", function()
        if require("luasnip").expand_or_jumpable() then
          require("luasnip").expand_or_jump()
        end
      end, { silent = true, desc = "Expandir o saltar en snippet" })

      vim.keymap.set({ "i", "s" }, "<C-h>", function()
        if require("luasnip").jumpable(-1) then
          require("luasnip").jump(-1)
        end
      end, { silent = true, desc = "Saltar atrás en snippet" })

      vim.keymap.set("i", "<C-e>", function()
        if require("luasnip").choice_active() then
          require("luasnip").change_choice(1)
        end
      end, { desc = "Cambiar opción en nodo choice" })
    end,
  },

  {
    "hrsh7th/nvim-cmp",
    dependencies = {
      "hrsh7th/cmp-nvim-lsp",
      "hrsh7th/cmp-buffer",
      "hrsh7th/cmp-path",
      "hrsh7th/cmp-cmdline",
      "hrsh7th/cmp-nvim-lua",
      "saadparwaiz1/cmp_luasnip",
      "onsails/lspkind.nvim",
      "rafamadriz/friendly-snippets",
      "kdheepak/cmp-latex-symbols",
      "jmbuhr/cmp-pandoc-references",
      "f3fora/cmp-spell",
      
    },
    config = function()
      local cmp = require("cmp")
      local luasnip = require("luasnip")
      local lspkind = require("lspkind")

      -- 1. PRIMERO: Definir grupos de highlight para que coincidan con Catppuccin
      vim.api.nvim_set_hl(0, "CmpPmenu",          { bg = "#1e1e2e" })  -- Fondo del menú
      vim.api.nvim_set_hl(0, "CmpBorder",         { fg = "#45475a" })  -- Color del borde 'single'
      vim.api.nvim_set_hl(0, "CmpSel",            { bg = "#585b70", bold = true }) -- Item seleccionado
      vim.api.nvim_set_hl(0, "CmpDoc",            { bg = "#181825" })  -- Fondo de documentación
      vim.api.nvim_set_hl(0, "CmpDocBorder",      { fg = "#45475a" })  -- Borde de documentación

      -- 2. Configuración principal de cmp
      cmp.setup({
        snippet = {
          expand = function(args)
            luasnip.lsp_expand(args.body)
          end,
        },
        mapping = cmp.mapping.preset.insert({
          ["<C-Space>"] = cmp.mapping.complete({ reason = cmp.ContextReason.Auto }),
          ["<CR>"] = cmp.mapping.confirm({
            behavior = cmp.ConfirmBehavior.Replace,
            select = true, -- CONFIRMA el item actualmente seleccionado
          }),
          ["<Tab>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
            elseif luasnip.expand_or_jumpable() then
              luasnip.expand_or_jump()
            elseif vim.snippet and vim.snippet.active({ direction = 1 }) then
              vim.snippet.jump(1)
            else
              fallback()
            end
          end, { "i", "s" }),
          ["<S-Tab>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_prev_item({ behavior = cmp.SelectBehavior.Select })
            elseif luasnip.jumpable(-1) then
              luasnip.jump(-1)
            elseif vim.snippet and vim.snippet.active({ direction = -1 }) then
              vim.snippet.jump(-1)
            else
              fallback()
            end
          end, { "i", "s" }),
          ["<C-j>"] = cmp.mapping.select_next_item({ behavior = cmp.SelectBehavior.Insert }),
          ["<C-k>"] = cmp.mapping.select_prev_item({ behavior = cmp.SelectBehavior.Insert }),
          ["<C-b>"] = cmp.mapping.scroll_docs(-4),
          ["<C-f>"] = cmp.mapping.scroll_docs(4),
          ["<C-e>"] = cmp.mapping.abort(),
          ["<C-d>"] = cmp.mapping(function()
            if cmp.visible() then
              cmp.select_next_item({ count = 5 })
            end
          end, { "i" }),
          ["<C-u>"] = cmp.mapping(function()
            if cmp.visible() then
              cmp.select_prev_item({ count = 5 })
            end
          end, { "i" }),
        }),
        sources = cmp.config.sources({
          { name = "nvim_lsp",    priority_weight = 100, max_item_count = 10 },
          { name = "luasnip",     priority_weight = 90,  max_item_count = 5 },
          { name = "nvim_lua",    priority_weight = 80 },
          { name = "path",        priority_weight = 70 },
          { name = "latex_symbols", priority_weight = 60, option = { strategy = 2 } },
          { name = "pandoc_references", priority_weight = 50 },
          { name = "spell",       priority_weight = 30, keyword_length = 3 },
        }, {
          { name = "buffer",      priority_weight = 20,
            option = {
              get_bufnrs = function()
                return vim.api.nvim_list_bufs()
              end,
              keyword_pattern = [[\%(-\?\d\+\%(\.\d\+\)\?\|\h\w*\%(-\w*\)*\)]],
              keyword_length = 3,
              max_item_count = 5,
            }
          },
        }),
        formatting = {
          format = lspkind.cmp_format({
            mode = "symbol_text",
            maxwidth = 40,
            ellipsis_char = "…",
            before = function(entry, vim_item)
              vim_item.menu = ({
                nvim_lsp = "[LSP]",
                luasnip = "[Snip]",
                nvim_lua = "[API]",
                path = "[Path]",
                buffer = "[Buf]",
                latex_symbols = "[LaTeX]",
                pandoc_references = "[Ref]",
                spell = "[Spell]",
              })[entry.source.name]
              return vim_item
            end,
          }),
        },
        experimental = {
          ghost_text = {
            hl_group = "Comment",
          },
          native_menu = false,
        },
        window = {
          completion = {
            border = "rounded",
            scrollbar = false, -- Más limpio sin barra de scroll
            winhighlight = "Normal:CmpPmenu,FloatBorder:CmpBorder,CursorLine:CmpSel,Search:None",
            max_width = 60,
            max_height = 12,
            col_offset = 0,
            side_padding = 1,
          },
          documentation = {
            border = "rounded",
            scrollbar = false,
            winhighlight = "Normal:CmpDoc,FloatBorder:CmpDocBorder,Search:None",
            max_width = 70,
            max_height = 15,
          },
        },
        performance = {
          debounce = 60,
          throttle = 100,
          fetching_timeout = 200,
          max_view_entries = 30,
        },
        preselect = cmp.PreselectMode.Item, -- SELECCIONA automáticamente el primer item
        completion = {
          completeopt = "menu,menuone,noinsert,noselect",
          autocomplete = {
            cmp.TriggerEvent.TextChanged,
            cmp.TriggerEvent.InsertEnter,
          },
          keyword_length = 1,
        },
        view = {
          entries = { name = "custom", selection_order = "near_cursor" },
        },
      })

      -- Configuración para línea de comandos
      cmp.setup.cmdline({ "/", "?" }, {
        mapping = cmp.mapping.preset.cmdline(),
        sources = {
          { name = "buffer", keyword_length = 2 },
        },
      })

      cmp.setup.cmdline(":", {
        mapping = cmp.mapping.preset.cmdline(),
        sources = cmp.config.sources(
          { { name = "path" } },
          { { name = "cmdline",
            option = {
              ignore_cmds = { "Man", "!" }
            }
          } }
        ),
      })

      -- Autocomando para desactivar completado en comentarios
      vim.api.nvim_create_autocmd("FileType", {
        pattern = { "*" },
        callback = function()
          vim.b.cmp_enabled = true
          local line = vim.api.nvim_get_current_line()
          local col = vim.api.nvim_win_get_cursor(0)[2]
          local before_cursor = line:sub(1, col)
          if before_cursor:match("^%s*#") or before_cursor:match("//") or before_cursor:match("^%s*--") then
            vim.b.cmp_enabled = false
          end
        end,
      })
    end,
  },
  {
    "rcarriga/nvim-notify",
    config = function()
      vim.notify = require("notify")
      require("notify").setup({
        timeout = 3000,
        max_height = function() return math.floor(vim.o.lines * 0.40) end,
        max_width = function() return math.floor(vim.o.columns * 0.40) end,
      })
    end,
  },

  { "lewis6991/gitsigns.nvim", config = true },

  { "folke/trouble.nvim",      config = true },

  {
    "lukas-reineke/indent-blankline.nvim",
    main = "ibl",
    opts = {},
  },

  {
    "nvimdev/dashboard-nvim",
    event = "VimEnter",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    config = function()
      local hyprcraft = [[
    ]]

      require("dashboard").setup({
        theme = "doom",
        config = {
          header = vim.split(hyprcraft, "\n"),
          center = {
            { icon = " ", desc = "NvimTree        ", key = "e", action = "NvimTreeToggle" },
            { icon = " ", desc = "Find Files      ", key = "f", action = "Telescope find_files" },
            { icon = " ", desc = "Recent Files    ", key = "r", action = "Telescope oldfiles" },
            { icon = " ", desc = "Live Grep       ", key = "g", action = "Telescope live_grep" },
            { icon = "󰚰 ", desc = "Update Plugins  ", key = "u", action = "Lazy update" },
            { icon = "󰩈 ", desc = "Quit            ", key = "q", action = "qa" },
          },
          footer = function()
            local stats = require("lazy").stats()
            local ms = (math.floor(stats.startuptime * 100 + 0.5) / 100)
            return { "", "HyprCraft 2025  •  " .. stats.count .. " plugins loaded in " .. ms .. "ms" }
          end,
        },
      })
    end,
  },

  {
    "folke/which-key.nvim",
    config = function()
      require("which-key").setup({ preset = "helix" })
    end,
  },

  { "mattn/emmet-vim" },
})

-- === LSP CONFIGURATION ===
local capabilities = require("cmp_nvim_lsp").default_capabilities()

-- Configurar Mason primero
-- Configuración optimizada de Mason
require("mason").setup({
  ui = {
    border = "single",
    icons = {
      package_installed = "✓",
      package_pending = "➜",
      package_uninstalled = "✗"
    }
  },
  max_concurrent_installers = 4,
})

-- Configuración robusta de servidores LSP
local servers = {
  lua_ls = {
    settings = {
      Lua = {
        runtime = { version = "LuaJIT" },
        diagnostics = { 
          globals = { "vim" },
          disable = { "missing-fields" }
        },
        workspace = { 
          checkThirdParty = false,
          library = vim.api.nvim_get_runtime_file("", true),
          maxPreload = 2000,
          preloadFileSize = 50000
        },
        telemetry = { enable = false },
        hint = {
          enable = true,
          arrayIndex = "Disable",
          await = true,
          paramName = "All",
          paramType = true,
          semicolon = "SameLine",
          setType = true,
        }
      }
    }
  },

  pyright = {
    settings = {
      python = {
        analysis = {
          typeCheckingMode = "basic",
          autoSearchPaths = true,
          useLibraryCodeForTypes = true,
          diagnosticMode = "workspace",
          autoImportCompletions = true,
          -- Opciones para reducir consumo
          indexing = true,
          importFormat = "absolute",
        }
      }
    }
  },

  -- TailwindCSS con configuración optimizada para reducir consumo
  tailwindcss = {
    filetypes = {
      "html", "javascript", "typescript", "javascriptreact", 
      "typescriptreact", "vue", "svelte", "astro", "php",
      "blade", "twig", "erb", "heex", "elixir"
    },
    settings = {
      tailwindCSS = {
        experimental = {
          classRegex = {
            "class: \"([^\"]*)\"",
            "className: \"([^\"]*)\"",
            "classNames: \"([^\"]*)\"",
            "tw`([^`]*)`",
            "tw=\"([^\"]*)\"",
            "tw={\"([^\"}]*)\"}",
          }
        },
        includeLanguages = {
          html = "html",
          javascript = "javascript",
          typescript = "typescript",
          javascriptreact = "javascriptreact",
          typescriptreact = "typescriptreact",
          vue = "vue",
          svelte = "svelte",
        },
        validate = true,
        lint = {
          cssConflict = "warning",
          invalidScreen = "error",
          invalidVariant = "error",
          invalidConfigPath = "error",
          invalidTailwindDirective = "error",
          recommendedVariantOrder = "warning"
        }
      }
    },
    init_options = {
      userLanguages = {
        elixir = "html-eex",
        erb = "html",
        heex = "html-eex",
      }
    },
    -- Configuración de rendimiento
    flags = {
      debounce_text_changes = 200,
    },
    -- Handler personalizado para manejar instalación
    setup = {
      cmd = { "tailwindcss-language-server", "--stdio" }
    }
  },

  html = {
    filetypes = { "html", "htmldjango", "blade", "php", "vue", "svelte" },
    settings = {
      html = {
        suggest = {},
        validate = { scripts = true, styles = true }
      }
    }
  },

  cssls = {
    filetypes = { "css", "scss", "less", "sass" },
    settings = {
      css = {
        validate = true,
        lint = {
          unknownAtRules = "ignore"
        }
      },
      scss = { validate = true },
      less = { validate = true },
      sass = { validate = true }
    }
  },


 
  emmet_language_server = {
    filetypes = {
      "html", "css", "scss", "less", "sass", "javascript", "typescript",
      "javascriptreact", "typescriptreact", "vue", "svelte", "php", "blade"
    },
    init_options = {
      html = {
        options = {
          ["bem.enabled"] = true,
        },
      },
    },
  },
}


-- Configuración mejorada de mason-lspconfig
require("mason-lspconfig").setup({
  ensure_installed = {
    "lua_ls",
    "pyright",
    "html",
    "cssls",
    "bashls",
    "jsonls",
    "tailwindcss",
    "emmet_language_server",
  },
  automatic_installation = true,
  
  handlers = {
    -- Handler por defecto
    function(server_name)
      local opts = servers[server_name] or {}
      opts.capabilities = capabilities
      
      -- Configuración específica para tailwindcss
      if server_name == "tailwindcss" then
        -- Verificar si el binario existe, si no, usar npx
        local util = require("lspconfig.util")
        local bin_path = util.path.join(
          vim.fn.stdpath("data"),
          "mason",
          "bin",
          "tailwindcss-language-server"
        )
        
        if vim.fn.executable(bin_path) == 1 then
          opts.cmd = { bin_path, "--stdio" }
        else
          -- Fallback a npx si no está instalado via mason
          opts.cmd = { "npx", "@tailwindcss/language-server", "--stdio" }
        end
      end
      
      require("lspconfig")[server_name].setup(opts)
    end,
    
    ["ltex"] = function()
      require("lspconfig").ltex.setup({
        capabilities = capabilities,
        settings = {
          ltex = {
            language = "es",
            dictionary = {},
            disabledRules = {},
            hiddenFalsePositives = {},
          }
        },
        on_attach = function(client, bufnr)
          -- Configuración específica para ltex
        end
      })
    end,
    
    -- Configuración especial para tsserver
    ["tsserver"] = function()
      require("lspconfig").tsserver.setup({
        capabilities = capabilities,
        settings = {
          typescript = {
            format = { enable = false },
            inlayHints = {
              includeInlayParameterNameHints = "none",
              includeInlayParameterNameHintsWhenArgumentMatchesName = false,
              includeInlayFunctionParameterTypeHints = false,
              includeInlayVariableTypeHints = false,
              includeInlayPropertyDeclarationTypeHints = false,
              includeInlayFunctionLikeReturnTypeHints = false,
              includeInlayEnumMemberValueHints = false,
            },
            suggest = {
              completeFunctionCalls = true,
            },
          },
          javascript = {
            format = { enable = false },
            inlayHints = {
              includeInlayParameterNameHints = "none",
              includeInlayParameterNameHintsWhenArgumentMatchesName = false,
              includeInlayFunctionParameterTypeHints = false,
              includeInlayVariableTypeHints = false,
              includeInlayPropertyDeclarationTypeHints = false,
              includeInlayFunctionLikeReturnTypeHints = false,
              includeInlayEnumMemberValueHints = false,
            },
            suggest = {
              completeFunctionCalls = true,
            },
          },
        },
        init_options = {
          preferences = {
            disableSuggestions = true,
          },
        },
      })
    end,
  }
})

-- Configuración global del LSP
vim.api.nvim_create_autocmd("LspAttach", {
  group = vim.api.nvim_create_augroup("UserLspConfig", {}),
  callback = function(ev)
    -- Atajos específicos del buffer
    local opts = { buffer = ev.buf }
    
    vim.keymap.set("n", "gd", vim.lsp.buf.definition, opts)
    vim.keymap.set("n", "K", vim.lsp.buf.hover, opts)
    vim.keymap.set("n", "<leader>ca", vim.lsp.buf.code_action, opts)
    vim.keymap.set("n", "<leader>rn", vim.lsp.buf.rename, opts)
    vim.keymap.set("n", "gr", vim.lsp.buf.references, opts)
    vim.keymap.set("n", "gi", vim.lsp.buf.implementation, opts)
    vim.keymap.set("n", "<leader>f", function()
      vim.lsp.buf.format({ async = true })
    end, opts)
    
    -- Diagnostic keymaps
    vim.keymap.set("n", "[d", vim.diagnostic.goto_prev, opts)
    vim.keymap.set("n", "]d", vim.diagnostic.goto_next, opts)
    vim.keymap.set("n", "<leader>d", vim.diagnostic.open_float, opts)
    
local client = vim.lsp.get_client_by_id(ev.data.client_id)
if client and client.name == "tailwindcss" then
    -- Aplicar límite de 300MB usando systemd-run
    client.config.cmd = {
        'systemd-run',
        '--user',
        '--scope',
        '-p', 'MemoryMax=420M',
        'tailwindcss-language-server',
        '--stdio'
    }
    vim.notify("TailwindCSS LSP activado - Límite de 300MB aplicado")
end
  end,
})

-- Configuración de diagnósticos mejorada
vim.diagnostic.config({
  virtual_text = {
    severity = { min = vim.diagnostic.severity.ERROR }, -- Solo errores en línea
    prefix = "●",
    format = function(diagnostic)
      return string.format("%s", diagnostic.message:match("([^\n]+)"))
    end,
  },
  signs = {
    text = {
      [vim.diagnostic.severity.ERROR] = "",
      [vim.diagnostic.severity.WARN] = "",
      [vim.diagnostic.severity.INFO] = "",
      [vim.diagnostic.severity.HINT] = "",
    },
  },
  underline = {
    severity = { min = vim.diagnostic.severity.WARN },
  },
  float = {
    border = "single",
    source = "if_many",
    format = function(diagnostic)
      return string.format("%s: %s", diagnostic.source, diagnostic.message)
    end,
  },
  update_in_insert = false, -- No actualizar mientras escribes
  severity_sort = true,
})

-- Comando para toggle de diagnósticos
local diagnostics_active = true
vim.api.nvim_create_user_command("ToggleDiagnostics", function()
  diagnostics_active = not diagnostics_active
  vim.diagnostic.config({
    virtual_text = diagnostics_active and { severity = { min = vim.diagnostic.severity.ERROR } } or false,
    underline = diagnostics_active and { severity = { min = vim.diagnostic.severity.WARN } } or false,
    signs = diagnostics_active,
  })
  vim.notify("Diagnósticos " .. (diagnostics_active and "activados" or "desactivados"))
end, {})

-- Atajo para el toggle
vim.keymap.set("n", "<leader>ud", "<cmd>ToggleDiagnostics<CR>", { desc = "Toggle diagnostics" })
-- === KEYMAPS ===
local wk = require("which-key")

wk.add({
  { "<leader>e",  ":NvimTreeToggle<CR>",             desc = "Explorer" },

  { "<leader>f",  group = "Find" },
  { "<leader>ff", ":Telescope find_files<CR>",       desc = "Files" },
  { "<leader>fg", ":Telescope live_grep<CR>",        desc = "Grep" },
  { "<leader>fb", ":Telescope buffers<CR>",          desc = "Buffers" },
  { "<leader>fo", ":Telescope oldfiles<CR>",         desc = "Old Files" },
  { "<leader>fh", ":Telescope help_tags<CR>",        desc = "Help" },

  { "<leader>w",  ":w<CR>",                          desc = "Save" },
  { "<leader>q",  ":q<CR>",                          desc = "Quit" },

  { "<leader>b",  group = "Buffer" },
  { "<leader>bd", ":bd<CR>",                         desc = "Delete" },

  { "<leader>x",  group = "Trouble" },
  { "<leader>xd", ":Trouble diagnostics toggle<CR>", desc = "Diagnostics" },
  { "<leader>xl", ":Trouble loclist toggle<CR>",     desc = "Loclist" },
  { "<leader>xq", ":Trouble quickfix toggle<CR>",    desc = "Quickfix" },
})

vim.keymap.set("n", "<Tab>", "<cmd>BufferLineCycleNext<CR>", { desc = "Next Buffer" })
vim.keymap.set("n", "<S-Tab>", "<cmd>BufferLineCyclePrev<CR>", { desc = "Prev Buffer" })
vim.keymap.set("n", "<Esc>", "<cmd>nohlsearch<CR><Esc>", { desc = "Clear Search" })

-- === LSP KEYMAPS ===
vim.api.nvim_create_autocmd("LspAttach", {
  callback = function(args)
    local buf = args.buf
    wk.add({
      { "gd",         vim.lsp.buf.definition,     desc = "Go to Definition", buffer = buf },
      { "K",          vim.lsp.buf.hover,          desc = "Hover",            buffer = buf },
      { "<leader>ca", vim.lsp.buf.code_action,    desc = "Code Action",      buffer = buf },
      { "<leader>rn", vim.lsp.buf.rename,         desc = "Rename",           buffer = buf },
      { "gr",         vim.lsp.buf.references,     desc = "References",       buffer = buf },
      { "gi",         vim.lsp.buf.implementation, desc = "Implementation",   buffer = buf },
    }, { buffer = buf })
  end,
})

-- === DIAGNOSTICS ===
vim.diagnostic.config({
  virtual_text = { prefix = "●" },
  signs = {
    text = {
      [vim.diagnostic.severity.ERROR] = "",
      [vim.diagnostic.severity.WARN] = "",
      [vim.diagnostic.severity.INFO] = "",
      [vim.diagnostic.severity.HINT] = "󰌶",
    },
  },
  float = { border = "rounded" },
})

-- === EMMET ===
vim.g.user_emmet_mode = 'a'
vim.g.user_emmet_leader_key = '<C-y>'
vim.g.user_emmet_install_global = 1
vim.g.user_emmet_complete_tag = 1
vim.g.user_emmet_expandabbr_key = '<C-y>,'

vim.g.user_emmet_settings = {
  variables = {
    lang = "es"
  },
  indent_blockelement = 1,
  javascript = {
    extends = 'jsx'
  },
  typescript = {
    extends = 'tsx'
  }
}

-- Activar Emmet para todos los tipos de archivo relevantes
vim.api.nvim_create_autocmd("FileType", {
  pattern = {
    "html", "htmldjango", "javascript", "javascriptreact", 
    "typescript", "typescriptreact", "vue", "svelte",
    "jsx", "tsx", "css", "scss", "less", "php", "blade"
  },
  callback = function()
    vim.cmd('EmmetInstall')
    vim.b.emmet_html = 1
  end
})

-- Mapeos simplificados y confiables
vim.api.nvim_create_autocmd("FileType", {
  pattern = {
    "html", "htmldjango", "javascript", "javascriptreact", 
    "typescript", "typescriptreact", "vue", "svelte",
    "jsx", "tsx"
  },
  callback = function()
    -- Mapeo principal para expandir abreviatura
    vim.keymap.set('i', '<C-y>,', '<Plug>(emmet-expand-abbr)', { 
      buffer = true, 
      desc = 'Emmet: Expand abbreviation' 
    })
    
    -- Mapeo alternativo con Enter
    vim.keymap.set('i', '<C-y><CR>', '<Plug>(emmet-expand-abbr)', { 
      buffer = true, 
      desc = 'Emmet: Expand abbreviation' 
    })
    
    -- Mapeo para siguiente punto de edición
    vim.keymap.set('i', '<C-y>n', '<Plug>(emmet-move-next)', { 
      buffer = true, 
      desc = 'Emmet: Next edit point' 
    })
    
    -- Mapeo para anterior punto de edición
    vim.keymap.set('i', '<C-y>N', '<Plug>(emmet-move-prev)', { 
      buffer = true, 
      desc = 'Emmet: Previous edit point' 
    })
    
    -- Mapeo inteligente con Tab
    vim.keymap.set('i', '<Tab>', function()
      local line = vim.api.nvim_get_current_line()
      local col = vim.api.nvim_win_get_cursor(0)[2]
      local before_cursor = line:sub(1, col)
      
      -- Detectar si estamos después de una abreviatura de Emmet
      if before_cursor:match("[%w%->!%[%]%+%*%(%)#%.%%$@_]+$") then
        local word = before_cursor:match("([%w%->!%[%]%+%*%(%)#%.%%$@_]+)$")
        if word and (word:match("^%a+%d*$") or word:match("^%.%a+") or word:match("^#%a+")) then
          return '<C-y>,'
        end
      end
      return '<Tab>'
    end, { expr = true, buffer = true, desc = 'Emmet expand or Tab' })
  end
})

-- Comando para verificar estado de Emmet
vim.api.nvim_create_user_command('EmmetStatus', function()
  print('Emmet global installed:', vim.g.user_emmet_install_global)
  print('Emmet leader key:', vim.g.user_emmet_leader_key)
  print('Current filetype:', vim.bo.filetype)
  print('Emmet active for buffer:', vim.b.emmet_html or 'no')
end, {})
